{"ast":null,"code":"import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nvar CachedKeyDecoder =\n/** @class */\nfunction () {\n  function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n    if (maxKeyLength === void 0) {\n      maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n    }\n\n    if (maxLengthPerKey === void 0) {\n      maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n    }\n\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n    this.hit = 0;\n    this.miss = 0; // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n\n    this.caches = [];\n\n    for (var i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  };\n\n  CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n    var records = this.caches[byteLength - 1];\n\n    FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n      var record = records_1[_i];\n      var recordBytes = record.bytes;\n\n      for (var j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n\n      return record.str;\n    }\n\n    return null;\n  };\n\n  CachedKeyDecoder.prototype.store = function (bytes, value) {\n    var records = this.caches[bytes.length - 1];\n    var record = {\n      bytes: bytes,\n      str: value\n    };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[Math.random() * records.length | 0] = record;\n    } else {\n      records.push(record);\n    }\n  };\n\n  CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n    var cachedValue = this.find(bytes, inputOffset, byteLength);\n\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n\n    this.miss++;\n    var str = utf8DecodeJs(bytes, inputOffset, byteLength); // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n\n    var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  };\n\n  return CachedKeyDecoder;\n}();\n\nexport { CachedKeyDecoder };","map":{"version":3,"mappings":"AAAA,SAASA,YAAT,QAA6B,kBAA7B;AAEA,IAAMC,sBAAsB,GAAG,EAA/B;AACA,IAAMC,0BAA0B,GAAG,EAAnC;;AAWA;AAAA;AAAA;EAKE,0BAAqBC,YAArB,EAAqEC,eAArE,EAAiH;IAA5F;MAAAD;IAAqC;;IAAW;MAAAC;IAA4C;;IAA5F;IAAgD;IAJrE,WAAM,CAAN;IACA,YAAO,CAAP,CAGiH,CAC/G;IACA;;IACA,KAAKC,MAAL,GAAc,EAAd;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKH,YAAzB,EAAuCG,CAAC,EAAxC,EAA4C;MAC1C,KAAKD,MAAL,CAAYE,IAAZ,CAAiB,EAAjB;IACD;EACF;;EAEMC,yCAAP,UAAmBC,UAAnB,EAAqC;IACnC,OAAOA,UAAU,GAAG,CAAb,IAAkBA,UAAU,IAAI,KAAKN,YAA5C;EACD,CAFM;;EAICK,kCAAR,UAAaE,KAAb,EAAgCC,WAAhC,EAAqDF,UAArD,EAAuE;IACrE,IAAMG,OAAO,GAAG,KAAKP,MAAL,CAAYI,UAAU,GAAG,CAAzB,CAAhB;;IAEAI,UAAU,EAAE,KAAqB,+BAArB,EAAqBC,qBAArB,EAAqBA,IAArB,EAA8B;MAAzB,IAAMC,MAAM,gBAAZ;MACf,IAAMC,WAAW,GAAGD,MAAM,CAACL,KAA3B;;MAEA,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,UAApB,EAAgCQ,CAAC,EAAjC,EAAqC;QACnC,IAAID,WAAW,CAACC,CAAD,CAAX,KAAmBP,KAAK,CAACC,WAAW,GAAGM,CAAf,CAA5B,EAA+C;UAC7C,SAASJ,UAAT;QACD;MACF;;MACD,OAAOE,MAAM,CAACG,GAAd;IACD;;IACD,OAAO,IAAP;EACD,CAdO;;EAgBAV,mCAAR,UAAcE,KAAd,EAAiCS,KAAjC,EAA8C;IAC5C,IAAMP,OAAO,GAAG,KAAKP,MAAL,CAAYK,KAAK,CAACU,MAAN,GAAe,CAA3B,CAAhB;IACA,IAAML,MAAM,GAAmB;MAAEL,KAAK,OAAP;MAASQ,GAAG,EAAEC;IAAd,CAA/B;;IAEA,IAAIP,OAAO,CAACQ,MAAR,IAAkB,KAAKhB,eAA3B,EAA4C;MAC1C;MACA;MACAQ,OAAO,CAAES,IAAI,CAACC,MAAL,KAAgBV,OAAO,CAACQ,MAAzB,GAAmC,CAApC,CAAP,GAAgDL,MAAhD;IACD,CAJD,MAIO;MACLH,OAAO,CAACL,IAAR,CAAaQ,MAAb;IACD;EACF,CAXO;;EAaDP,oCAAP,UAAcE,KAAd,EAAiCC,WAAjC,EAAsDF,UAAtD,EAAwE;IACtE,IAAMc,WAAW,GAAG,KAAKC,IAAL,CAAUd,KAAV,EAAiBC,WAAjB,EAA8BF,UAA9B,CAApB;;IACA,IAAIc,WAAW,IAAI,IAAnB,EAAyB;MACvB,KAAKE,GAAL;MACA,OAAOF,WAAP;IACD;;IACD,KAAKG,IAAL;IAEA,IAAMR,GAAG,GAAGlB,YAAY,CAACU,KAAD,EAAQC,WAAR,EAAqBF,UAArB,CAAxB,CARsE,CAStE;;IACA,IAAMkB,iBAAiB,GAAGC,UAAU,CAACC,SAAX,CAAqBC,KAArB,CAA2BC,IAA3B,CAAgCrB,KAAhC,EAAuCC,WAAvC,EAAoDA,WAAW,GAAGF,UAAlE,CAA1B;IACA,KAAKuB,KAAL,CAAWL,iBAAX,EAA8BT,GAA9B;IACA,OAAOA,GAAP;EACD,CAbM;;EAcT;AAAC,CA7DD","names":["utf8DecodeJs","DEFAULT_MAX_KEY_LENGTH","DEFAULT_MAX_LENGTH_PER_KEY","maxKeyLength","maxLengthPerKey","caches","i","push","CachedKeyDecoder","byteLength","bytes","inputOffset","records","FIND_CHUNK","_i","record","recordBytes","j","str","value","length","Math","random","cachedValue","find","hit","miss","slicedCopyOfBytes","Uint8Array","prototype","slice","call","store"],"sources":["/Users/j/Code/ore-test-barebones-node-v14/create-react-app/react-app-test/node_modules/@msgpack/msgpack/src/CachedKeyDecoder.ts"],"sourcesContent":["import { utf8DecodeJs } from \"./utils/utf8\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH, readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}