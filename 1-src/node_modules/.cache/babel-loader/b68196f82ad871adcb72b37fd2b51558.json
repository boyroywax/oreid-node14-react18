{"ast":null,"code":"var _a, _b, _c;\n/* eslint-disable @typescript-eslint/no-unnecessary-condition */\n\n\nimport { UINT32_MAX } from \"./int.mjs\";\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[\"TEXT_ENCODING\"]) !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\nexport function utf8Count(str) {\n  var strLength = str.length;\n  var byteLength = 0;\n  var pos = 0;\n\n  while (pos < strLength) {\n    var value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          var extra = str.charCodeAt(pos);\n\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n\n  return byteLength;\n}\nexport function utf8EncodeJs(str, output, outputOffset) {\n  var strLength = str.length;\n  var offset = outputOffset;\n  var pos = 0;\n\n  while (pos < strLength) {\n    var value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = value >> 6 & 0x1f | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          var extra = str.charCodeAt(pos);\n\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = value >> 12 & 0x0f | 0xe0;\n        output[offset++] = value >> 6 & 0x3f | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = value >> 18 & 0x07 | 0xf0;\n        output[offset++] = value >> 12 & 0x3f | 0x80;\n        output[offset++] = value >> 6 & 0x3f | 0x80;\n      }\n    }\n\n    output[offset++] = value & 0x3f | 0x80;\n  }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? UINT32_MAX : typeof process !== \"undefined\" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b[\"TEXT_ENCODING\"]) !== \"force\" ? 200 : 0;\n\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n  output.set(sharedTextEncoder.encode(str), outputOffset);\n}\n\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nexport function utf8DecodeJs(bytes, inputOffset, byteLength) {\n  var offset = inputOffset;\n  var end = offset + byteLength;\n  var units = [];\n  var result = \"\";\n\n  while (offset < end) {\n    var byte1 = bytes[offset++];\n\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      var byte2 = bytes[offset++] & 0x3f;\n      units.push((byte1 & 0x1f) << 6 | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      var byte2 = bytes[offset++] & 0x3f;\n      var byte3 = bytes[offset++] & 0x3f;\n      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      var byte2 = bytes[offset++] & 0x3f;\n      var byte3 = bytes[offset++] & 0x3f;\n      var byte4 = bytes[offset++] & 0x3f;\n      var unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(unit >>> 10 & 0x3ff | 0xd800);\n        unit = 0xdc00 | unit & 0x3ff;\n      }\n\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode.apply(String, units);\n  }\n\n  return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? UINT32_MAX : typeof process !== \"undefined\" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c[\"TEXT_DECODER\"]) !== \"force\" ? 200 : 0;\nexport function utf8DecodeTD(bytes, inputOffset, byteLength) {\n  var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder.decode(stringBytes);\n}","map":{"version":3,"mappings":"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","names":["UINT32_MAX","TEXT_ENCODING_AVAILABLE","process","env","_a","TextEncoder","TextDecoder","utf8Count","str","strLength","length","byteLength","pos","value","charCodeAt","extra","utf8EncodeJs","output","outputOffset","offset","sharedTextEncoder","undefined","TEXT_ENCODER_THRESHOLD","_b","utf8EncodeTEencode","set","encode","utf8EncodeTEencodeInto","encodeInto","subarray","utf8EncodeTE","CHUNK_SIZE","utf8DecodeJs","bytes","inputOffset","end","units","result","byte1","push","byte2","byte3","byte4","unit","String","fromCharCode","apply","sharedTextDecoder","TEXT_DECODER_THRESHOLD","_c","utf8DecodeTD","stringBytes","decode"],"sources":["/Users/j/Code/ore-test-barebones-node-v14/create-react-app/react-app-test/node_modules/@msgpack/msgpack/src/utils/utf8.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unnecessary-condition */\nimport { UINT32_MAX } from \"./int\";\n\nconst TEXT_ENCODING_AVAILABLE =\n  (typeof process === \"undefined\" || process?.env?.[\"TEXT_ENCODING\"] !== \"never\") &&\n  typeof TextEncoder !== \"undefined\" &&\n  typeof TextDecoder !== \"undefined\";\n\nexport function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\nconst sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport const TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n  ? UINT32_MAX\n  : typeof process !== \"undefined\" && process?.env?.[\"TEXT_ENCODING\"] !== \"force\"\n  ? 200\n  : 0;\n\nfunction utf8EncodeTEencode(str: string, output: Uint8Array, outputOffset: number): void {\n  output.set(sharedTextEncoder!.encode(str), outputOffset);\n}\n\nfunction utf8EncodeTEencodeInto(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder!.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport const utf8EncodeTE = sharedTextEncoder?.encodeInto ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport const TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n  ? UINT32_MAX\n  : typeof process !== \"undefined\" && process?.env?.[\"TEXT_DECODER\"] !== \"force\"\n  ? 200\n  : 0;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder!.decode(stringBytes);\n}\n"]},"metadata":{},"sourceType":"module"}