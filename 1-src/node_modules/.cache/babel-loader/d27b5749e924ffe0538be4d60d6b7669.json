{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nvar __await = this && this.__await || function (v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\n\nvar __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n};\n\nimport { prettyByte } from \"./utils/prettyByte.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.mjs\";\nimport { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8.mjs\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays.mjs\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.mjs\";\nimport { DecodeError } from \"./DecodeError.mjs\";\n\nvar isValidMapKeyType = function (key) {\n  var keyType = typeof key;\n  return keyType === \"string\" || keyType === \"number\";\n};\n\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer); // IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\n\nexport var DataViewIndexOutOfBoundsError = function () {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e) {\n    return e.constructor;\n  }\n\n  throw new Error(\"never reached\");\n}();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nvar Decoder =\n/** @class */\nfunction () {\n  function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n    if (extensionCodec === void 0) {\n      extensionCodec = ExtensionCodec.defaultCodec;\n    }\n\n    if (context === void 0) {\n      context = undefined;\n    }\n\n    if (maxStrLength === void 0) {\n      maxStrLength = UINT32_MAX;\n    }\n\n    if (maxBinLength === void 0) {\n      maxBinLength = UINT32_MAX;\n    }\n\n    if (maxArrayLength === void 0) {\n      maxArrayLength = UINT32_MAX;\n    }\n\n    if (maxMapLength === void 0) {\n      maxMapLength = UINT32_MAX;\n    }\n\n    if (maxExtLength === void 0) {\n      maxExtLength = UINT32_MAX;\n    }\n\n    if (keyDecoder === void 0) {\n      keyDecoder = sharedCachedKeyDecoder;\n    }\n\n    this.extensionCodec = extensionCodec;\n    this.context = context;\n    this.maxStrLength = maxStrLength;\n    this.maxBinLength = maxBinLength;\n    this.maxArrayLength = maxArrayLength;\n    this.maxMapLength = maxMapLength;\n    this.maxExtLength = maxExtLength;\n    this.keyDecoder = keyDecoder;\n    this.totalPos = 0;\n    this.pos = 0;\n    this.view = EMPTY_VIEW;\n    this.bytes = EMPTY_BYTES;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack = [];\n  }\n\n  Decoder.prototype.reinitializeState = function () {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.length = 0; // view, bytes, and pos will be re-initialized in setBuffer()\n  };\n\n  Decoder.prototype.setBuffer = function (buffer) {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  };\n\n  Decoder.prototype.appendBuffer = function (buffer) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      var remainingData = this.bytes.subarray(this.pos);\n      var newData = ensureUint8Array(buffer); // concat remainingData + newData\n\n      var newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  };\n\n  Decoder.prototype.hasRemaining = function (size) {\n    return this.view.byteLength - this.pos >= size;\n  };\n\n  Decoder.prototype.createExtraByteError = function (posToShow) {\n    var _a = this,\n        view = _a.view,\n        pos = _a.pos;\n\n    return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n  };\n  /**\n   * @throws {DecodeError}\n   * @throws {RangeError}\n   */\n\n\n  Decoder.prototype.decode = function (buffer) {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n    var object = this.doDecodeSync();\n\n    if (this.hasRemaining(1)) {\n      throw this.createExtraByteError(this.pos);\n    }\n\n    return object;\n  };\n\n  Decoder.prototype.decodeMulti = function (buffer) {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          this.reinitializeState();\n          this.setBuffer(buffer);\n          _a.label = 1;\n\n        case 1:\n          if (!this.hasRemaining(1)) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , this.doDecodeSync()];\n\n        case 2:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 1];\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  Decoder.prototype.decodeAsync = function (stream) {\n    var stream_1, stream_1_1;\n\n    var e_1, _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            decoded = false;\n            _c.label = 1;\n\n          case 1:\n            _c.trys.push([1, 6, 7, 12]);\n\n            stream_1 = __asyncValues(stream);\n            _c.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , stream_1.next()];\n\n          case 3:\n            if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3\n            /*break*/\n            , 5];\n            buffer = stream_1_1.value;\n\n            if (decoded) {\n              throw this.createExtraByteError(this.totalPos);\n            }\n\n            this.appendBuffer(buffer);\n\n            try {\n              object = this.doDecodeSync();\n              decoded = true;\n            } catch (e) {\n              if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                throw e; // rethrow\n              } // fallthrough\n\n            }\n\n            this.totalPos += this.pos;\n            _c.label = 4;\n\n          case 4:\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [3\n            /*break*/\n            , 12];\n\n          case 6:\n            e_1_1 = _c.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 12];\n\n          case 7:\n            _c.trys.push([7,, 10, 11]);\n\n            if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3\n            /*break*/\n            , 9];\n            return [4\n            /*yield*/\n            , _a.call(stream_1)];\n\n          case 8:\n            _c.sent();\n\n            _c.label = 9;\n\n          case 9:\n            return [3\n            /*break*/\n            , 11];\n\n          case 10:\n            if (e_1) throw e_1.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 11:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 12:\n            if (decoded) {\n              if (this.hasRemaining(1)) {\n                throw this.createExtraByteError(this.totalPos);\n              }\n\n              return [2\n              /*return*/\n              , object];\n            }\n\n            _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n            throw new RangeError(\"Insufficient data in parsing \".concat(prettyByte(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n        }\n      });\n    });\n  };\n\n  Decoder.prototype.decodeArrayStream = function (stream) {\n    return this.decodeMultiAsync(stream, true);\n  };\n\n  Decoder.prototype.decodeStream = function (stream) {\n    return this.decodeMultiAsync(stream, false);\n  };\n\n  Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n    return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n      var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n\n      var e_3, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            isArrayHeaderRequired = isArray;\n            arrayItemsLeft = -1;\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 13, 14, 19]);\n\n            stream_2 = __asyncValues(stream);\n            _b.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , __await(stream_2.next())];\n\n          case 3:\n            if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3\n            /*break*/\n            , 12];\n            buffer = stream_2_1.value;\n\n            if (isArray && arrayItemsLeft === 0) {\n              throw this.createExtraByteError(this.totalPos);\n            }\n\n            this.appendBuffer(buffer);\n\n            if (isArrayHeaderRequired) {\n              arrayItemsLeft = this.readArraySize();\n              isArrayHeaderRequired = false;\n              this.complete();\n            }\n\n            _b.label = 4;\n\n          case 4:\n            _b.trys.push([4, 9,, 10]);\n\n            _b.label = 5;\n\n          case 5:\n            if (!true) return [3\n            /*break*/\n            , 8];\n            return [4\n            /*yield*/\n            , __await(this.doDecodeSync())];\n\n          case 6:\n            return [4\n            /*yield*/\n            , _b.sent()];\n\n          case 7:\n            _b.sent();\n\n            if (--arrayItemsLeft === 0) {\n              return [3\n              /*break*/\n              , 8];\n            }\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 8:\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            e_2 = _b.sent();\n\n            if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n              throw e_2; // rethrow\n            }\n\n            return [3\n            /*break*/\n            , 10];\n\n          case 10:\n            this.totalPos += this.pos;\n            _b.label = 11;\n\n          case 11:\n            return [3\n            /*break*/\n            , 2];\n\n          case 12:\n            return [3\n            /*break*/\n            , 19];\n\n          case 13:\n            e_3_1 = _b.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3\n            /*break*/\n            , 19];\n\n          case 14:\n            _b.trys.push([14,, 17, 18]);\n\n            if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3\n            /*break*/\n            , 16];\n            return [4\n            /*yield*/\n            , __await(_a.call(stream_2))];\n\n          case 15:\n            _b.sent();\n\n            _b.label = 16;\n\n          case 16:\n            return [3\n            /*break*/\n            , 18];\n\n          case 17:\n            if (e_3) throw e_3.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 18:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 19:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Decoder.prototype.doDecodeSync = function () {\n    DECODE: while (true) {\n      var headByte = this.readHeadByte();\n      var object = void 0;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          var size = headByte - 0x80;\n\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          var size = headByte - 0x90;\n\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          var byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        var byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        var byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        var byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        var size = this.readU16();\n\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        var size = this.readU32();\n\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        var size = this.readU16();\n\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        var size = this.readU32();\n\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        var size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        var size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        var size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        var size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        var size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        var size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(\"Unrecognized type byte: \".concat(prettyByte(headByte)));\n      }\n\n      this.complete();\n      var stack = this.stack;\n\n      while (stack.length > 0) {\n        // arrays and maps\n        var state = stack[stack.length - 1];\n\n        if (state.type === 0\n        /* ARRAY */\n        ) {\n          state.array[state.position] = object;\n          state.position++;\n\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === 1\n        /* MAP_KEY */\n        ) {\n          if (!isValidMapKeyType(object)) {\n            throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n          }\n\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = object;\n          state.type = 2\n          /* MAP_VALUE */\n          ;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n          state.map[state.key] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = 1\n            /* MAP_KEY */\n            ;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  };\n\n  Decoder.prototype.readHeadByte = function () {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8(); // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  };\n\n  Decoder.prototype.complete = function () {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  };\n\n  Decoder.prototype.readArraySize = function () {\n    var headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n\n      case 0xdd:\n        return this.readU32();\n\n      default:\n        {\n          if (headByte < 0xa0) {\n            return headByte - 0x90;\n          } else {\n            throw new DecodeError(\"Unrecognized array type byte: \".concat(prettyByte(headByte)));\n          }\n        }\n    }\n  };\n\n  Decoder.prototype.pushMapState = function (size) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n    }\n\n    this.stack.push({\n      type: 1\n      /* MAP_KEY */\n      ,\n      size: size,\n      key: null,\n      readCount: 0,\n      map: {}\n    });\n  };\n\n  Decoder.prototype.pushArrayState = function (size) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n    }\n\n    this.stack.push({\n      type: 0\n      /* ARRAY */\n      ,\n      size: size,\n      array: new Array(size),\n      position: 0\n    });\n  };\n\n  Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n    var _a;\n\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    var offset = this.pos + headerOffset;\n    var object;\n\n    if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else if (byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(this.bytes, offset, byteLength);\n    } else {\n      object = utf8DecodeJs(this.bytes, offset, byteLength);\n    }\n\n    this.pos += headerOffset + byteLength;\n    return object;\n  };\n\n  Decoder.prototype.stateIsMapKey = function () {\n    if (this.stack.length > 0) {\n      var state = this.stack[this.stack.length - 1];\n      return state.type === 1\n      /* MAP_KEY */\n      ;\n    }\n\n    return false;\n  };\n\n  Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    var offset = this.pos + headOffset;\n    var object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  };\n\n  Decoder.prototype.decodeExtension = function (size, headOffset) {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n    }\n\n    var extType = this.view.getInt8(this.pos + headOffset);\n    var data = this.decodeBinary(size, headOffset + 1\n    /* extType */\n    );\n    return this.extensionCodec.decode(data, extType, this.context);\n  };\n\n  Decoder.prototype.lookU8 = function () {\n    return this.view.getUint8(this.pos);\n  };\n\n  Decoder.prototype.lookU16 = function () {\n    return this.view.getUint16(this.pos);\n  };\n\n  Decoder.prototype.lookU32 = function () {\n    return this.view.getUint32(this.pos);\n  };\n\n  Decoder.prototype.readU8 = function () {\n    var value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  };\n\n  Decoder.prototype.readI8 = function () {\n    var value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  };\n\n  Decoder.prototype.readU16 = function () {\n    var value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  };\n\n  Decoder.prototype.readI16 = function () {\n    var value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  };\n\n  Decoder.prototype.readU32 = function () {\n    var value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  };\n\n  Decoder.prototype.readI32 = function () {\n    var value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  };\n\n  Decoder.prototype.readU64 = function () {\n    var value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  };\n\n  Decoder.prototype.readI64 = function () {\n    var value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  };\n\n  Decoder.prototype.readF32 = function () {\n    var value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  };\n\n  Decoder.prototype.readF64 = function () {\n    var value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  };\n\n  return Decoder;\n}();\n\nexport { Decoder };","map":{"version":3,"mappings":"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","names":["prettyByte","ExtensionCodec","getInt64","getUint64","UINT32_MAX","utf8DecodeJs","TEXT_DECODER_THRESHOLD","utf8DecodeTD","createDataView","ensureUint8Array","CachedKeyDecoder","DecodeError","isValidMapKeyType","key","keyType","HEAD_BYTE_REQUIRED","EMPTY_VIEW","DataView","ArrayBuffer","EMPTY_BYTES","Uint8Array","buffer","DataViewIndexOutOfBoundsError","getInt8","e","constructor","Error","MORE_DATA","sharedCachedKeyDecoder","extensionCodec","context","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","defaultCodec","undefined","Decoder","totalPos","headByte","stack","length","bytes","view","pos","hasRemaining","setBuffer","remainingData","subarray","newData","newBuffer","set","size","byteLength","posToShow","RangeError","concat","reinitializeState","object","doDecodeSync","createExtraByteError","_a","stream","decoded","stream_1","appendBuffer","_b","decodeMultiAsync","isArray","isArrayHeaderRequired","arrayItemsLeft","stream_2","readArraySize","complete","e_2","DECODE","readHeadByte","pushMapState","pushArrayState","decodeUtf8String","readF32","readF64","readU8","readU16","readU32","readU64","readI8","readI16","readI32","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","state","type","array","position","pop","map","readCount","push","Array","headerOffset","offset","stateIsMapKey","canBeCached","decode","headOffset","extType","data","getUint8","getUint16","getUint32","value","getInt16","getInt32","getFloat32","getFloat64"],"sources":["/Users/j/Code/ore-test-barebones-node-v14/create-react-app/react-app-test/node_modules/@msgpack/msgpack/src/Decoder.ts"],"sourcesContent":["import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int\";\nimport { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\nimport { DecodeError } from \"./DecodeError\";\n\nconst enum State {\n  ARRAY,\n  MAP_KEY,\n  MAP_VALUE,\n}\n\ntype MapKeyType = string | number;\n\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\n  const keyType = typeof key;\n\n  return keyType === \"string\" || keyType === \"number\";\n};\n\ntype StackMapState = {\n  type: State.MAP_KEY | State.MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: State.ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport const DataViewIndexOutOfBoundsError: typeof Error = (() => {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e: any) {\n    return e.constructor;\n  }\n  throw new Error(\"never reached\");\n})();\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack: Array<StackState> = [];\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxStrLength = UINT32_MAX,\n    private readonly maxBinLength = UINT32_MAX,\n    private readonly maxArrayLength = UINT32_MAX,\n    private readonly maxMapLength = UINT32_MAX,\n    private readonly maxExtLength = UINT32_MAX,\n    private readonly keyDecoder: KeyDecoder | null = sharedCachedKeyDecoder,\n  ) {}\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.length = 0;\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | BufferSource): void {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | BufferSource) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {DecodeError}\n   * @throws {RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | BufferSource): unknown {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    const object = this.doDecodeSync();\n    if (this.hasRemaining(1)) {\n      throw this.createExtraByteError(this.pos);\n    }\n    return object;\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | BufferSource): Generator<unknown, void, unknown> {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    while (this.hasRemaining(1)) {\n      yield this.doDecodeSync();\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>): Promise<unknown> {\n    let decoded = false;\n    let object: unknown;\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.doDecodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n      return object;\n    }\n\n    const { headByte, pos, totalPos } = this;\n    throw new RangeError(\n      `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n    );\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | BufferSource>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | BufferSource>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>, isArray: boolean) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.doDecodeSync();\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1]!;\n        if (state.type === State.ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === State.MAP_KEY) {\n          if (!isValidMapKeyType(object)) {\n            throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n          }\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = object;\n          state.type = State.MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = State.MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: State.MAP_KEY,\n      size,\n      key: null,\n      readCount: 0,\n      map: {},\n    });\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: State.ARRAY,\n      size,\n      array: new Array<unknown>(size),\n      position: 0,\n    });\n  }\n\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else if (byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(this.bytes, offset, byteLength);\n    } else {\n      object = utf8DecodeJs(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1]!;\n      return state.type === State.MAP_KEY;\n    }\n    return false;\n  }\n\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}